#!/usr/bin/env python3.5
# -*- coding: utf-8 -*-
import os
import sys
import traceback
import inspect
import logging
import time


from PyQt5.QtGui import QGuiApplication
from PyQt5.QtQml import QQmlApplicationEngine
from PyQt5.QtCore import QObject, QRunnable, QThreadPool, QSettings
from PyQt5.QtCore import pyqtSignal, pyqtSlot, pyqtProperty

from ftplib import FTP
from shutil import which, unpack_archive
from requests import get
from subprocess import run


__VERSION__ = '0.1'

COMPANY = 'ARKZilla'
USERAGENT = {'User-Agent': COMPANY + __VERSION__}


def log(message):
    """
    Log message with function name and string number
    """
    func = inspect.currentframe().f_back.f_code
    # Dump the message + the name of this function to the log.
    logging.debug("%s: %s() in %s:%i" % (
                  message,
                  func.co_name,
                  func.co_filename,
                  func.co_firstlineno))


def rpr(data, indent=0, s='  ', color=True):
    COLOR = '\033[92m' if color else ''
    DEFAULT = '\033[0m' if color else ''
    if type(data) is dict:
        for key, val in data.items():
            if type(val) in [dict, list]:
                print(u'{i}{c}{key}{d}:'.format(i=indent*s, key=key, c=COLOR, d=DEFAULT))
                rpr(val, indent+1, s)
            else:
                print(u'{i}{c}{key}{d}: {val}'.format(i=indent*s, key=key, val=val, c=COLOR, d=DEFAULT))
    elif type(data) is list:
        for val in data:
            if type(val) in [dict, list]:
                rpr(val, indent, s)
    print("\n")


class Progress(object):
    """
    Helper class for progress calculation
    Simplified version of Progressbar: https://github.com/anler/progressbar
    """
    def __init__(self, start=0, end=10, incremental=True):
        super(Progress, self).__init__()
        self.__start = start
        self.__end = end
        self.__progress = float(self.__start) if incremental else float(self.__end)
        self.__previous = self.__progress

    def __add__(self, increment):
        if self.__end > self.__progress + increment:
            self.__progress += increment
        else:
            self.__progress = float(self.__end)
        return self

    def __sub__(self, decrement):
        if self.__start < self.__progress - decrement:
            self.__progress -= decrement
        else:
            self.__progress = float(self.__start)
        return self

    def percent(self):
        result = int(self.__progress / self.__end * 100)
        # Return False if percent not changed (do not emit bunch of signals)
        if result != self.__previous:
            self.__previous = result
            return result
        else:
            return False


class Worker(QRunnable):
    '''
    Worker thread

    Inherits from QRunnable to handler worker thread setup, signals and wrap-up.

    :param callback: The function callback to run on this worker thread. Supplied args and
                     kwargs will be passed through to the runner.
    :type callback: function
    :param args: Arguments to pass to the callback function
    :param kwargs: Keywords to pass to the callback function

    '''

    def __init__(self, fn, *args, **kwargs):
        super(Worker, self).__init__()

        # Store constructor arguments (re-used for processing)
        self.fn = fn
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()

        # Add the callback to our kwargs
        kwargs['progress_callback'] = self.signals.progress

    @pyqtSlot()
    def run(self):
        '''
        Initialise the runner function with passed args, kwargs.
        '''

        # Retrieve args/kwargs here; and fire processing using them
        try:
            result = self.fn(*self.args, **self.kwargs)
        except Exception:
            traceback.print_exc()
            err_type, err = sys.exc_info()[:2]
            log('%s: %s' % (err_type, err))
            self.signals.error.emit(str(err))
        else:
            self.signals.result.emit(result)  # Return the result of the processing
        finally:
            self.signals.finished.emit()  # Done


class WorkerSignals(QObject):
    '''
    Defines the signals available from a running worker thread.

    Supported signals are:

    finished
        No data

    error
        `tuple` (exctype, value, traceback.format_exc() )

    result
        `object` data returned from processing, anything

    progress
        `int` indicating % progress

    '''
    finished = pyqtSignal()
    error = pyqtSignal(str)
    result = pyqtSignal(object)
    progress = pyqtSignal(int)


class Client(QObject):
    """
    Communication and data source management
    """

    def __init__(self):
        super(Client, self).__init__()
        # Init local data path
        self.__cwd = os.getcwd()
        self.__downloadPath = os.path.join(self.__cwd, 'download')
        self.__dataPath = os.path.join(self.__cwd, 'data')
        os.makedirs(self.__downloadPath, exist_ok=True)
        os.makedirs(self.__dataPath, exist_ok=True)

    def updatePrefix(self, prefix):
        """
        Update local data path prefixed with remote host name
        """
        self.__downloadPath = os.path.join(self.__cwd, 'download', prefix)
        self.__dataPath = os.path.join(self.__cwd, 'data', prefix)
        os.makedirs(self.__downloadPath, exist_ok=True)
        os.makedirs(self.__dataPath, exist_ok=True)

    def testConnection(self, progress_callback, host, login, password):
        '''
        Test Connection
        '''
        ftp = FTP()
        ftp.connect(host, timeout=5)
        ftp.login(user=login, passwd=password)
        ftp.close()
        return True

    def listRemote(self, progress_callback, host, login, password, remote):
        """
        Get list of backups from remote server
        """
        ftp = FTP()
        ftp.connect(host, timeout=5)
        ftp.login(user=login, passwd=password)
        remote = ftp.nlst(os.path.join(remote, '*.ark'))
        ftp.close()

        # Return only filenames without path
        result = []
        for item in remote:
            fname = item.split('/')[-1]
            # Only add entries with timestamps
            if '_' in fname:
                result.append(fname)

        return result

    def listLocal(self):
        """
        Get list of downloaded backups
        """
        result = []
        for fname in os.listdir(self.__downloadPath):
            if os.path.isfile(os.path.join(self.__downloadPath, fname)):
                result.append(fname)

        return result

    def isLocal(self, file):
        """
        Return true if downloaded
        """
        return os.path.isfile(os.path.join(self.__downloadPath, file))

    def download(self, progress_callback, host, login, password, remote, filename):
        """
        Download file with progress callback
        """
        ftp = FTP()
        ftp.connect(host, timeout=5)
        ftp.login(user=login, passwd=password)
        ftp.sendcmd("TYPE i")
        filesize = ftp.size(os.path.join(remote, filename))
        progress = Progress(end=filesize)
        with open(os.path.join(self.__downloadPath, filename), 'wb') as f:

            def callback(chunk):
                f.write(chunk)
                progress + len(chunk)
                percent = progress.percent()
                if percent:
                    progress_callback.emit(percent)

            ftp.retrbinary('RETR {}'.format(os.path.join(remote, filename)), callback)
        ftp.close()
        return True

    def remove(self, progress_callback, filename):
        """
        Remove downloaded file and unpacked data with progress callback
        """
        dataDir = os.path.join(self.__dataPath, filename)
        backup = os.path.join(self.__downloadPath, filename)

        # Build list of items to be removed
        paths = list()
        if os.path.exists(dataDir) and os.path.isdir(dataDir):
            for root, dirs, files in os.walk(dataDir, topdown=False):
                for item in files:
                    paths.append(os.path.join(root, item))
                for item in dirs:
                    paths.append(os.path.join(root, item))
        paths.append(backup)

        # Remove files and emit progress callback
        progress = Progress(end=len(paths))
        for item in paths:
            if os.path.isdir(item):
                os.rmdir(item)
            else:
                os.remove(item)
            progress + 1
            percent = progress.percent()
            if percent:
                progress_callback.emit(percent)
        return True

    def unpack(self, progress_callback, filename, tools):
        """
        Unpack specified backup using ark-tools
        """
        dataDir = os.path.join(self.__dataPath, filename)
        backup = os.path.join(self.__downloadPath, filename)
        # Check if backup already unpacked
        if os.path.exists(os.path.join(dataDir, '.complete')):
            return

        # Download ark-tools if not exists
        deftools = os.path.join(self.__cwd, 'tools', 'ark-tools.jar')
        if not os.path.exists(tools):
            if os.path.exists(deftools):
                tools = deftools
            else:
                tools = self.setupTools()

        # Check and download ark_data.json
        if not os.path.exists(os.path.join(self.__cwd, 'tools', 'ark_data.json')):
            args = ['java', '-jar', tools, '--quiet', 'update-data']
            run(args)

        # Unpack backup
        os.makedirs(dataDir, exist_ok=True)
        args = ['java', '-jar', tools, '--quiet', 'tamed', '--clean', '--write-all-fields', backup, dataDir]
        r = run(args)
        if r.returncode == 0:
            open(os.path.join(dataDir, '.complete'), 'a').close()
        else:
            return False

    def setupTools(self):
        """
        Download and unpack ark-tools
        """
        log('ark-tools.jar not found. begin download...')
        # Get archive name to download
        url = None
        r = get('https://api.github.com/repos/Qowyn/ark-tools/releases/latest', headers=USERAGENT)
        if r.status_code == 200:
            items = r.json()
            for item in items['assets']:
                if item['content_type'] == 'application/x-zip-compressed':
                    url = item['browser_download_url']
        else:
            return None

        # Download ark-tools archive
        r = get(url, headers=USERAGENT)
        if r.status_code == 200:
            dir = os.path.join(self.__cwd, 'tools')
            os.makedirs(dir, exist_ok=True)
            archive = os.path.join(dir, 'ark-tools.zip')
            with open(archive, 'wb') as f:
                f.write(r.content)
            f.close()
            # Unpack and delete downloaded archive
            unpack_archive(archive, dir, format='zip')
            os.remove(archive)
            return os.path.join(dir, 'ark-tools.jar')

        return None


class ARKZilla(QObject):
    '''
    Main class
    '''

    connectionError = pyqtSignal(str, arguments=['error'])
    connectionSuccess = pyqtSignal()
    syncError = pyqtSignal(str, arguments=['error'])
    syncComplete = pyqtSignal(list, arguments=['model'])
    downloadError = pyqtSignal(str, arguments=['error'])
    downloadComplete = pyqtSignal()
    downloadProgress = pyqtSignal(int, arguments=['percent'])
    removeError = pyqtSignal(str, arguments=['error'])
    removeComplete = pyqtSignal()
    removeProgress = pyqtSignal(int, arguments=['percent'])
    unpackError = pyqtSignal(str, arguments=['error'])
    unpackComplete = pyqtSignal()
    javaNotFound = pyqtSignal()
    themeChanged = pyqtSignal()
    hostChanged = pyqtSignal()

    def __init__(self):
        super(ARKZilla, self).__init__()

        self.__settings = QSettings(COMPANY, sys.argv[0])
        self.__sessionPass = ''
        self.__storePass = False

        self.__threadpool = QThreadPool()
        print("Multithreading with maximum %d threads" % self.__threadpool.maxThreadCount())

        self.__client = Client()
        if self.host:
            self.__client.updatePrefix(prefix=self.host)

    @pyqtProperty(str, notify=hostChanged)
    def host(self):
        return self.__settings.value('host')

    @host.setter
    def host(self, value):
        self.__settings.setValue('host', value)
        self.__client.updatePrefix(prefix=value)
        self.hostChanged.emit()

    @pyqtProperty(str, constant=True)
    def login(self):
        return self.__settings.value('login', 'anonymous')

    @login.setter
    def login(self, value):
        self.__settings.setValue('login', value)

    @pyqtProperty(str, constant=True)
    def password(self):
        return self.__settings.contains('password') and self.__settings.value('password') or self.__sessionPass

    @password.setter
    def password(self, value):
        if self.__storePass:
            self.__settings.setValue('password', value)
        else:
            self.__sessionPass = value

    @pyqtProperty(bool, constant=True)
    def storePass(self):
        return self.__settings.contains('password')

    @storePass.setter
    def storePass(self, value):
        if (not value):
            self.__settings.remove('password')
        self.__storePass = value

    @pyqtProperty(str, constant=True)
    def remotePath(self):
        return self.__settings.value('remotePath', '/')

    @remotePath.setter
    def remotePath(self, value):
        self.__settings.setValue('remotePath', value)

    @pyqtProperty(str, constant=True)
    def toolsPath(self):
        return self.__settings.value('toolsPath', '')

    @toolsPath.setter
    def toolsPath(self, value):
        self.__settings.setValue('toolsPath', value)

    @pyqtProperty(bool, notify=themeChanged)
    def darkTheme(self):
        return self.__settings.value('darkTheme', False, type=bool)

    @darkTheme.setter
    def darkTheme(self, value):
        self.__settings.setValue('darkTheme', value)
        self.themeChanged.emit()

    @pyqtSlot(str, str, str)
    def testConnection(self, host, login, password):
        """
        Slot for test connection thread

        :param host: Host from settingsUI
        :param login: Login from settingsUI
        :param password: Password from settingsUI
        """
        worker = Worker(self.__client.testConnection,
                        host=host,
                        login=login,
                        password=password
                        )
        worker.signals.result.connect(self.connectionSuccess)
        worker.signals.error.connect(self.connectionError)
        self.__threadpool.start(worker)

    @pyqtSlot()
    def syncModel(self):
        """
        Slot for getting remote files list in thread
        Send results to syncWithLocal slot
        """
        worker = Worker(self.__client.listRemote,
                        host=self.host,
                        login=self.login,
                        password=self.password,
                        remote=self.remotePath)
        worker.signals.result.connect(self.syncWithLocal)
        worker.signals.error.connect(self.syncError)
        self.__threadpool.start(worker)

    @pyqtSlot()
    @pyqtSlot(object)
    def syncWithLocal(self, remote=list()):
        """
        Merge remote data with local in one model.
        Sort items by date, mark local files and send results to ListView

        :param remote: list of remote files. come from syncModel
        """
        local = self.__client.listLocal()

        model = []
        # Join and prepare two lists
        for item in list(set(local + remote)):
            # Is file downloaded?
            local = self.__client.isLocal(item)
            name = item.split('_')[:1].pop()
            # Format date and time
            dateRaw = item[:-4].split('_', 1)[1:].pop()
            date = time.strftime("%Y.%m.%d %H:%M",
                                 time.strptime(dateRaw, "%d.%m.%Y_%H.%M.%S"))
            # Append to final model
            model.append({
                        'local': local,
                        'name': name,
                        'date': date,
                        'filename': item
                        })

        # Sort by date, and reverse list
        model.sort(key=lambda r: time.strptime(r['date'], "%Y.%m.%d %H:%M"), reverse=True)

        # Send to ListView
        self.syncComplete.emit(model)

    @pyqtSlot(str)
    def download(self, fname):
        """
        Slot for downloading remote file in thread

        :param fname: filename to download
        """
        worker = Worker(self.__client.download,
                        host=self.host,
                        login=self.login,
                        password=self.password,
                        remote=self.remotePath,
                        filename=fname)
        worker.signals.result.connect(self.downloadComplete)
        worker.signals.error.connect(self.downloadError)
        worker.signals.progress.connect(self.downloadProgress)
        self.__threadpool.start(worker)

    @pyqtSlot(str)
    def remove(self, fname):
        """
        Slot for removing local data in thread

        :param fname: filename to remove
        """
        worker = Worker(self.__client.remove, filename=fname)
        worker.signals.result.connect(self.removeComplete)
        worker.signals.error.connect(self.removeError)
        worker.signals.progress.connect(self.removeProgress)
        self.__threadpool.start(worker)

    @pyqtSlot(str)
    def unpack(self, fname):
        """
        Slot for unpacking local data in thread

        :param fname: filename to unpack
        """
        # Check java exists
        if not which('java'):
            self.javaNotFound.emit()
            return
        worker = Worker(self.__client.unpack, filename=fname, tools=self.toolsPath)
        worker.signals.result.connect(self.unpackComplete)
        worker.signals.error.connect(self.unpackError)
        self.__threadpool.start(worker)


if __name__ == "__main__":
    # Set Material Design style
    os.environ["QT_QUICK_CONTROLS_STYLE"] = "Material"

    # Setup logger
    logging.basicConfig(filename='{}.log'.format(sys.argv[0]),
                        level=logging.DEBUG,
                        format='%(asctime)s - %(levelname)s - %(message)s')

    app = QGuiApplication(sys.argv)
    app.setOrganizationName(COMPANY)
    app.setApplicationName(sys.argv[0])

    arkzilla = ARKZilla()

    engine = QQmlApplicationEngine()
    engine.rootContext().setContextProperty('arkzilla', arkzilla)
    engine.load("main.qml")
    engine.quit.connect(app.quit)

    sys.exit(app.exec_())
